{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Admin\\\\Scratch\\\\frontend\\\\src\\\\contexts\\\\AuthContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect } from 'react';\n\n// The context is created. Components will use this to get the value.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext(null);\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  // 1. Use a single state object for all auth-related data.\n  // This makes it easier to manage and pass around.\n  const [auth, setAuth] = useState(null); // This will hold { user, token }\n\n  // 2. Use a clear 'isLoading' flag for the initial check.\n  const [isLoading, setIsLoading] = useState(true);\n  useEffect(() => {\n    // This effect runs only once when the app starts.\n    // Its job is to check localStorage and initialize the auth state.\n    try {\n      const storedToken = localStorage.getItem('token');\n      const storedUser = localStorage.getItem('user');\n      if (storedToken && storedUser) {\n        // If we find a user and token, we set the auth state.\n        setAuth({\n          token: storedToken,\n          user: JSON.parse(storedUser)\n        });\n      }\n    } catch (error) {\n      console.error(\"Failed to parse auth data from localStorage. Clearing storage.\", error);\n      // If data is corrupted, clear it to prevent errors.\n      localStorage.removeItem('user');\n      localStorage.removeItem('token');\n    } finally {\n      // CRITICAL: This ALWAYS runs, ensuring the app doesn't get stuck loading.\n      setIsLoading(false);\n    }\n  }, []); // The empty array [] means this effect runs only on the initial mount.\n\n  // The login function now sets the entire auth object.\n  const login = (userData, token) => {\n    const authData = {\n      user: userData,\n      token: token\n    };\n    localStorage.setItem('user', JSON.stringify(userData));\n    localStorage.setItem('token', token);\n    setAuth(authData);\n  };\n\n  // The logout function clears everything.\n  const logout = () => {\n    localStorage.removeItem('user');\n    localStorage.removeItem('token');\n    setAuth(null);\n  };\n\n  // This function allows other components to update the user part of the auth object.\n  const updateUserContext = updatedUserData => {\n    setAuth(prevAuth => {\n      // Create a new user object by merging the old and new data.\n      const newUser = {\n        ...prevAuth.user,\n        ...updatedUserData\n      };\n      // Create the new, complete auth object for state.\n      const newAuth = {\n        ...prevAuth,\n        user: newUser\n      };\n      // Update localStorage with the new user data.\n      localStorage.setItem('user', JSON.stringify(newUser));\n      return newAuth;\n    });\n  };\n\n  // 3. The value provided to all child components now has a consistent structure.\n  const contextValue = {\n    auth,\n    // The object containing { user, token }\n    isLoading,\n    // The flag to check if initial loading is complete\n    login,\n    logout,\n    updateUser: updateUserContext // Give it a clear name\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 77,\n    columnNumber: 5\n  }, this);\n};\n_s(AuthProvider, \"IZDu6W5IjHAn/H5HcG6NwnGBTZw=\");\n_c = AuthProvider;\nexport default AuthContext;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","jsxDEV","_jsxDEV","AuthContext","AuthProvider","children","_s","auth","setAuth","isLoading","setIsLoading","storedToken","localStorage","getItem","storedUser","token","user","JSON","parse","error","console","removeItem","login","userData","authData","setItem","stringify","logout","updateUserContext","updatedUserData","prevAuth","newUser","newAuth","contextValue","updateUser","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Admin/Scratch/frontend/src/contexts/AuthContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect } from 'react';\r\n\r\n// The context is created. Components will use this to get the value.\r\nconst AuthContext = createContext(null);\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n  // 1. Use a single state object for all auth-related data.\r\n  // This makes it easier to manage and pass around.\r\n  const [auth, setAuth] = useState(null); // This will hold { user, token }\r\n\r\n  // 2. Use a clear 'isLoading' flag for the initial check.\r\n  const [isLoading, setIsLoading] = useState(true);\r\n\r\n  useEffect(() => {\r\n    // This effect runs only once when the app starts.\r\n    // Its job is to check localStorage and initialize the auth state.\r\n    try {\r\n      const storedToken = localStorage.getItem('token');\r\n      const storedUser = localStorage.getItem('user');\r\n\r\n      if (storedToken && storedUser) {\r\n        // If we find a user and token, we set the auth state.\r\n        setAuth({\r\n          token: storedToken,\r\n          user: JSON.parse(storedUser),\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to parse auth data from localStorage. Clearing storage.\", error);\r\n      // If data is corrupted, clear it to prevent errors.\r\n      localStorage.removeItem('user');\r\n      localStorage.removeItem('token');\r\n    } finally {\r\n      // CRITICAL: This ALWAYS runs, ensuring the app doesn't get stuck loading.\r\n      setIsLoading(false);\r\n    }\r\n  }, []); // The empty array [] means this effect runs only on the initial mount.\r\n\r\n  // The login function now sets the entire auth object.\r\n  const login = (userData, token) => {\r\n    const authData = { user: userData, token: token };\r\n    localStorage.setItem('user', JSON.stringify(userData));\r\n    localStorage.setItem('token', token);\r\n    setAuth(authData);\r\n  };\r\n\r\n  // The logout function clears everything.\r\n  const logout = () => {\r\n    localStorage.removeItem('user');\r\n    localStorage.removeItem('token');\r\n    setAuth(null);\r\n  };\r\n  \r\n  // This function allows other components to update the user part of the auth object.\r\n  const updateUserContext = (updatedUserData) => {\r\n    setAuth(prevAuth => {\r\n      // Create a new user object by merging the old and new data.\r\n      const newUser = { ...prevAuth.user, ...updatedUserData };\r\n      // Create the new, complete auth object for state.\r\n      const newAuth = { ...prevAuth, user: newUser };\r\n      // Update localStorage with the new user data.\r\n      localStorage.setItem('user', JSON.stringify(newUser));\r\n      return newAuth;\r\n    });\r\n  };\r\n\r\n  // 3. The value provided to all child components now has a consistent structure.\r\n  const contextValue = {\r\n    auth,           // The object containing { user, token }\r\n    isLoading,      // The flag to check if initial loading is complete\r\n    login,\r\n    logout,\r\n    updateUser: updateUserContext, // Give it a clear name\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={contextValue}>\r\n      {/* \r\n        We no longer need the `!isLoading && children` check here.\r\n        The `PrivateRoute` component will handle the loading state individually.\r\n        This is more flexible and prevents the entire app from being blank during the initial check.\r\n      */}\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n\r\nexport default AuthContext;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;;AAEjE;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,WAAW,gBAAGL,aAAa,CAAC,IAAI,CAAC;AAEvC,OAAO,MAAMM,YAAY,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAC5C;EACA;EACA,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGT,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;;EAExC;EACA,MAAM,CAACU,SAAS,EAAEC,YAAY,CAAC,GAAGX,QAAQ,CAAC,IAAI,CAAC;EAEhDC,SAAS,CAAC,MAAM;IACd;IACA;IACA,IAAI;MACF,MAAMW,WAAW,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;MACjD,MAAMC,UAAU,GAAGF,YAAY,CAACC,OAAO,CAAC,MAAM,CAAC;MAE/C,IAAIF,WAAW,IAAIG,UAAU,EAAE;QAC7B;QACAN,OAAO,CAAC;UACNO,KAAK,EAAEJ,WAAW;UAClBK,IAAI,EAAEC,IAAI,CAACC,KAAK,CAACJ,UAAU;QAC7B,CAAC,CAAC;MACJ;IACF,CAAC,CAAC,OAAOK,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gEAAgE,EAAEA,KAAK,CAAC;MACtF;MACAP,YAAY,CAACS,UAAU,CAAC,MAAM,CAAC;MAC/BT,YAAY,CAACS,UAAU,CAAC,OAAO,CAAC;IAClC,CAAC,SAAS;MACR;MACAX,YAAY,CAAC,KAAK,CAAC;IACrB;EACF,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;;EAER;EACA,MAAMY,KAAK,GAAGA,CAACC,QAAQ,EAAER,KAAK,KAAK;IACjC,MAAMS,QAAQ,GAAG;MAAER,IAAI,EAAEO,QAAQ;MAAER,KAAK,EAAEA;IAAM,CAAC;IACjDH,YAAY,CAACa,OAAO,CAAC,MAAM,EAAER,IAAI,CAACS,SAAS,CAACH,QAAQ,CAAC,CAAC;IACtDX,YAAY,CAACa,OAAO,CAAC,OAAO,EAAEV,KAAK,CAAC;IACpCP,OAAO,CAACgB,QAAQ,CAAC;EACnB,CAAC;;EAED;EACA,MAAMG,MAAM,GAAGA,CAAA,KAAM;IACnBf,YAAY,CAACS,UAAU,CAAC,MAAM,CAAC;IAC/BT,YAAY,CAACS,UAAU,CAAC,OAAO,CAAC;IAChCb,OAAO,CAAC,IAAI,CAAC;EACf,CAAC;;EAED;EACA,MAAMoB,iBAAiB,GAAIC,eAAe,IAAK;IAC7CrB,OAAO,CAACsB,QAAQ,IAAI;MAClB;MACA,MAAMC,OAAO,GAAG;QAAE,GAAGD,QAAQ,CAACd,IAAI;QAAE,GAAGa;MAAgB,CAAC;MACxD;MACA,MAAMG,OAAO,GAAG;QAAE,GAAGF,QAAQ;QAAEd,IAAI,EAAEe;MAAQ,CAAC;MAC9C;MACAnB,YAAY,CAACa,OAAO,CAAC,MAAM,EAAER,IAAI,CAACS,SAAS,CAACK,OAAO,CAAC,CAAC;MACrD,OAAOC,OAAO;IAChB,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAMC,YAAY,GAAG;IACnB1B,IAAI;IAAY;IAChBE,SAAS;IAAO;IAChBa,KAAK;IACLK,MAAM;IACNO,UAAU,EAAEN,iBAAiB,CAAE;EACjC,CAAC;EAED,oBACE1B,OAAA,CAACC,WAAW,CAACgC,QAAQ;IAACC,KAAK,EAAEH,YAAa;IAAA5B,QAAA,EAMvCA;EAAQ;IAAAgC,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACW,CAAC;AAE3B,CAAC;AAAClC,EAAA,CAhFWF,YAAY;AAAAqC,EAAA,GAAZrC,YAAY;AAkFzB,eAAeD,WAAW;AAAC,IAAAsC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}